import*as elasticlunr from"elasticlunr";import{withPathPrefix}from"../utils";import*as fetchImport from"unfetch";elasticlunr&&elasticlunr.tokenizer.setSeperator(/[\s\-.\/]+/g);const fetch=fetchImport.default||fetchImport;export class SearchIndex{constructor(a){this._index=elasticlunr.Index.load(a)}async search(a,b=50){let c={};const d=this._index.search(a,{expand:!0,bool:"AND",fields:{content:{boost:1},title:{boost:1}}});for(let e=0;e<Math.min(b,d.length);e++){const{ref:a,score:b}=d[e],f=this._index.documentStore.getDoc(a),g=f.headings[0],h=f.link;c[h]?(f.meta&&c[h].meta.push(f.meta),c[h].score=Math.max(c[h].score,b)):c[h]={label:g,link:h,score:b,meta:f.meta?[f.meta]:[],content:f.content,httpVerb:f.httpVerb}}const e=Object.values(c);return e.sort((c,a)=>a.score-c.score),e}}export class RemoteSearchIndex{constructor(a,b){this.endpoint=a,this.pathPrefix=b}async search(a,b=50){const c=window.location.origin+withPathPrefix(this.endpoint,this.pathPrefix);return fetch(c+"?q="+encodeURIComponent(a)+"&l="+encodeURIComponent(b.toString())).then(a=>a.json()).then(a=>a.results)}}export class SearchService{constructor(){this._searchIndex=null,this._indexLoadError=!1,this.search=async(a,b=100)=>{if(!this._searchIndex)throw new Error("Must initialize search index first");let c=await this._searchIndex;return c?c.search(a,b):{message:"index load error"}}}init(a="",b="",c="search-index.json"){a.endsWith("/")&&(a=a.substring(0,a.length-1));const d=b?`${b}/${c}`:window.location.origin+withPathPrefix(c,a);`undefined`!=typeof window&&(this._searchIndex=fetch(d+"?i=1").then(a=>a.json()).then(b=>b&&b.__portal_server?new RemoteSearchIndex(c,a):new SearchIndex(b)).catch(()=>null))}}